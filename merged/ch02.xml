<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter>
  <title>A Tour of the Dart Language</title>

  <para>This chapter shows you how to use each major Dart feature, from
  variables and operators to classes and libraries, with the assumption that
  you already know how to program in another language.</para>

  <note>
    <para>To play with each feature, create a server application project in
    Dart Editor, as described in <xref linkend="ch01-editor" />.</para>
  </note>

  <para>Consult the <ulink url="http://www.dartlang.org/docs/spec/">Dart
  Language Specification</ulink> whenever you want more details about a
  language feature.</para>

  <sect1 id="main-print">
    <title>A basic Dart program</title>

    <para>The following code uses many of Dart’s most basic features.</para>

    <programlisting>// Define a function.
printNumber(num aNumber) {
  print(&apos;The number is $aNumber.&apos;); // Print to the console.
}

// This is where the app starts executing.
main() {
  var number = 42;           // Declare and initialize a variable.
  printNumber(number);       // Call a function.
}</programlisting>

    <para>Here’s what this program uses that applies to all (or almost all)
    Dart apps:</para>

    <variablelist>
      <varlistentry>
        <term><literal>// <replaceable>This is a
        comment.</replaceable></literal></term>

        <listitem>
          <para>Use // to indicate that the rest of the line is a comment.
          Alternatively, use /* ... */. For details, see <xref
          linkend="comments" />.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>num</literal></term>

        <listitem>
          <para>A type. Some of the other built-in types are String, int, and
          bool.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>100</literal></term>

        <listitem>
          <para>A number <glossterm>literal</glossterm>. Literals are a kind
          of compile-time constant.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>print()</literal></term>

        <listitem>
          <para>A handy way to display output.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>'...'</literal> (or <literal>"..."</literal>)</term>

        <listitem>
          <para>A string literal.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>$<replaceable>variableName</replaceable></literal> (or
        <literal>${<replaceable>expression</replaceable></literal><literal>}</literal>)</term>

        <listitem>
          <para>String interpolation: including a variable or expression’s
          string equivalent inside of a string literal. For more information,
          see <xref linkend="strings" />.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>main()</literal></term>

        <listitem>
          <para>The special, <emphasis>required</emphasis>, top-level function
          where app execution starts.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>var</literal></term>

        <listitem>
          <para>A way to declare a variable without specifying its
          type.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <note>
      <para>Our code follows the conventions in the <ulink
      url="http://www.dartlang.org/articles/style-guide/">Dart Style
      Guide.</ulink> For example, we use two-space indentation.</para>
    </note>
  </sect1>

  <sect1 id="ch02-concepts">
    <title>Important concepts</title>

    <para>As you learn about the Dart language, keep these facts and concepts
    in mind:</para>

    <itemizedlist>
      <listitem>
        <para>Everything you can place in a variable is an
        <emphasis>object</emphasis>, and every object is an instance of a
        <emphasis>class</emphasis>. Even numbers and functions are objects.
        All objects inherit from the <ulink
        url="http://api.dartlang.org/dart_core/Object.html">Object</ulink>
        class.</para>
      </listitem>

      <listitem>
        <para>Specifying static types (such as <literal>num</literal> in the
        preceding example) clarifies your intent and enables static checking
        by tools, but it’s optional. (You might notice when you’re debugging
        your code that objects with no specified type get a special type:
        <literal>dynamic</literal>.)</para>
      </listitem>

      <listitem>
        <para>Dart parses all your code before running it. You can provide
        tips to Dart—for example, by using types or compile-time constants—to
        catch errors or help your code run faster.</para>
      </listitem>

      <listitem>
        <para>Dart supports top-level functions (such as main()), as well as
        functions tied to a class or object (<emphasis>static</emphasis> and
        <emphasis>instance methods</emphasis>, respectively).</para>
      </listitem>

      <listitem>
        <para>Similarly, Dart supports top-level
        <emphasis>variables</emphasis>, as well as variables tied to a class
        or object (static and instance variables). Instance variables are
        sometimes known as <glossterm>fields</glossterm> or
        <glossterm>properties</glossterm>.</para>
      </listitem>

      <listitem>
        <para>Unlike Java, Dart doesn’t have the keywords
        <literal>public</literal>, <literal>protected</literal>, and
        <literal>private</literal>. If an identifier starts with an underscore
        (_), it’s private to its library. For details, see <xref
        linkend="libraries" />.</para>
      </listitem>

      <listitem>
        <para><glossterm>Identifiers</glossterm> can start with a letter or _,
        followed by any combination of those characters plus digits.</para>
      </listitem>

      <listitem>
        <para>Sometimes it matters whether something is an
        <emphasis>expression</emphasis> or a <emphasis>statement</emphasis>,
        so we’ll be precise about those two words.</para>
      </listitem>

      <listitem>
        <para>Dart tools can report two kinds of errors: warnings and errors.
        Warnings are just hints that your code might not work, but they don’t
        prevent your program from executing. Errors can be either compile-time
        or run-time. A compile-time error prevents the code from executing at
        all; a run-time error results in an exception <xref
        linkend="exceptions" xrefstyle="select:page" /> being raised while the
        code executes.</para>
      </listitem>

      <listitem>
        <para>Dart has two <glossterm>runtime modes</glossterm>: production
        and checked. Production is faster, but checked is helpful at
        development.</para>
      </listitem>
    </itemizedlist>

    <sect2 id="ch02-runtime-modes">
      <title>Runtime modes</title>

      <para>We recommend that you develop and debug in checked mode, and
      deploy to production mode.</para>

      <para><emphasis>Production mode</emphasis> is the default runtime mode
      of a Dart program, optimized for speed. Production mode ignores assert
      statements <xref linkend="assert" xrefstyle="select:page" /> and static
      types.</para>

      <para><emphasis>Checked mode</emphasis> is a developer-friendly mode
      that helps you catch some type errors during runtime. For example, if
      you assign a non-number to a variable declared as a
      <literal>num</literal>, then checked mode throws an exception.</para>
    </sect2>
  </sect1>

  <sect1 id="variables">
    <title>Variables</title>

    <para>Here’s an example of creating a variable and assigning a value to
    it:</para>

    <programlisting>var name = &apos;Bob&apos;;</programlisting>

    <para>Variables are references. The variable called
    <literal>name</literal> contains a reference to a String object with a
    value of <quote>Bob</quote>.</para>

    <sect2 id="variables-default-value">
      <title>Default value</title>

      <para>Uninitialized variables have an initial value of
      <literal>null</literal>. Even variables with numeric types are initially
      null, because numbers are objects.</para>

      <programlisting>int lineCount;
assert(lineCount == null); // Variables (even if they will be numbers) are initially null.</programlisting>

      <note>
        <para>The assert() call is ignored in production mode. In checked
        mode, <literal>assert(<replaceable>condition</replaceable>)</literal>
        throws an exception unless <replaceable>condition</replaceable> is
        true. For details, see <xref linkend="assert" />.</para>
      </note>
    </sect2>

    <sect2 id="variables-optional-types">
      <title>Optional types</title>

      <para>You have the option of adding static types to your variable
      declarations:</para>

      <programlisting>String name = &apos;Bob&apos;;</programlisting>

      <para>Adding types is a way to clearly express your intent. Tools such
      as compilers and editors can use these types to help you, by providing
      early warnings for bugs and code completion.</para>

      <note>
        <para>This chapter follows the <ulink
        url="http://www.dartlang.org/articles/style-guide/#type-annotations">style
        guide recommendation</ulink> of using <literal>var</literal>, rather
        than type annotations, for local variables.</para>
      </note>
    </sect2>

    <sect2>
      <title>Final and const</title>

      <para>If you never intend to change a variable, use
      <literal>final</literal> or <literal>const</literal>, either instead of
      <literal>var</literal> or in addition to a type. A final variable can be
      set only once; a const variable is a compile-time constant.</para>

      <para>A local, top-level, or class variable that’s declared as
      <literal>final</literal> is initialized the first time it’s used.</para>

      <programlisting>final name = &apos;Bob&apos;;   // Or: final String name = &apos;Bob&apos;;
// name = &apos;Alice&apos;;    // Uncommenting this results in an error</programlisting>

      <note>
        <para>Lazy initialization of final variables helps apps start up
        faster.</para>
      </note>

      <para>Use <literal>const</literal> for variables that you want to be
      compile-time constants. Where you declare the variable, set the value to
      a compile-time constant such as a literal, a const variable, or the
      result of an arithmetic operation on constant numbers.</para>

      <programlisting>const bar = 1000000;       // Unit of pressure (in dynes/cm2)
const atm = 1.01325 * bar; // Standard atmosphere</programlisting>
    </sect2>
  </sect1>

  <sect1 id="built-in-types">
    <title>Built-in types</title>

    <para>The Dart language has special support for the following
    types:</para>

    <itemizedlist>
      <listitem>
        <simpara>numbers</simpara>
      </listitem>

      <listitem>
        <simpara>strings</simpara>
      </listitem>

      <listitem>
        <simpara>booleans</simpara>
      </listitem>

      <listitem>
        <simpara>lists (also known as <emphasis>arrays</emphasis>)</simpara>
      </listitem>

      <listitem>
        <simpara>maps</simpara>
      </listitem>
    </itemizedlist>

    <para>You can initialize an object of any of these special types using a
    literal. For example, <literal>'this is a string'</literal> is a string
    literal, and <literal>true</literal> is a boolean literal.</para>

    <para>Because every variable in Dart refers to an object—an instance of a
    <emphasis>class</emphasis>—you can usually use
    <emphasis>constructors</emphasis> to initialize variables. Some of the
    built-in types have their own constructors. For example, you can use the
    Map() constructor to create a map, using code such as <literal>new
    Map()</literal>.</para>

    <sect2 id="numbers">
      <title>Numbers</title>

      <para>Dart numbers come in two flavors:</para>

      <variablelist>
        <varlistentry>
          <term><ulink
          url="http://api.dartlang.org/dart_core/int.html"><literal>int</literal></ulink></term>

          <listitem>
            <para>Integers of arbitrary size</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><ulink
          url="http://api.dartlang.org/dart_core/double.html"><literal>double</literal></ulink></term>

          <listitem>
            <para>64-bit (double-precision) floating-point numbers, as
            specified by the IEEE 754 standard</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Both <literal>int</literal> and <literal>double</literal> are
      subtypes of <ulink
      url="http://api.dartlang.org/dart_core/num.html"><literal>num</literal>.</ulink>
      The num type includes basic operators such as +, -, /, and *, as well as
      bitwise operators such as &gt;&gt;. The num type is also where you’ll
      find abs(), ceil(), and floor(), among other methods. If num and its
      subtypes don’t have what you’re looking for, the <ulink
      url="http://api.dartlang.org/dart_core/Math.html">Math</ulink> class
      might.</para>

      <para>Integers are numbers without a decimal point. Here are some
      examples of defining integer literals:</para>

      <programlisting>var x = 1;
var hex = 0xDEADBEEF;
var bigInt = 346534658346524376592384765923749587398457294759347029438709349347;</programlisting>

      <note>
        <para>In JavaScript produced from Dart code, big integers currently
        behave differently than they do when the same Dart code runs in the
        Dart VM. For details, see <ulink
        url="http://dartbug.com/1533"></ulink>.</para>
      </note>

      <para>If a number includes a decimal, it is a double. Here are some
      examples of defining double literals:</para>

      <programlisting>var y = 1.1;
var exponents = 1.42e5;</programlisting>

      <para>Here’s how you turn a string into a number, or vice versa:</para>

      <programlisting>// String -&gt; int
var one = int.parse(&apos;1&apos;);
assert(one == 1);

// String -&gt; double
var onePointOne = double.parse(&apos;1.1&apos;);
assert(onePointOne == 1.1);

// int -&gt; String
String oneAsString = 1.toString();
assert(oneAsString == &apos;1&apos;);

// double -&gt; String
String piAsString = 3.14159.toStringAsFixed(2);
assert(piAsString == &apos;3.14&apos;);</programlisting>

      <para>The num type specifies the traditional bitwise shift (&lt;&lt;,
      &gt;&gt;), AND (&amp;), and OR (|) operators. For example:</para>

      <programlisting>assert((3 &lt;&lt; 1) == 6);  // 0011 &lt;&lt; 1 == 0110
assert((3 &gt;&gt; 1) == 1);  // 0011 &gt;&gt; 1 == 0001
assert((3 | 4)  == 7);  // 0011 | 0100 == 0111</programlisting>
    </sect2>

    <sect2 id="strings">
      <title>Strings</title>

      <para>A Dart string is a sequence of UTF-16 code units. You can use
      either single or double quotes to create a string:</para>

      <programlisting>var s1 = &apos;Single quotes work well for string literals.&apos;;
var s2 = &quot;Double quotes work just as well.&quot;;
var s3 = &apos;It\&apos;s easy to escape the string delimiter.&apos;;
var s4 = &quot;It&apos;s even easier to just use the other string delimiter.&quot;;</programlisting>

      <para>You can put the value of an expression inside a string by using
      ${<emphasis>expression</emphasis>}. If the expression is an identifier,
      you can skip the {}. To get the string corresponding to an object, Dart
      calls the object’s toString() method.</para>

      <programlisting>var s = &apos;string interpolation&apos;;

assert(&apos;Dart has $s, which is very handy.&apos; ==
       &apos;Dart has string interpolation, which is very handy.&apos;);
assert(&apos;That deserves all caps. ${s.toUpperCase()} is very handy!&apos; ==
       &apos;That deserves all caps. STRING INTERPOLATION is very handy!&apos;);</programlisting>

      <note>
        <para>The <literal>==</literal> operator tests whether two objects are
        equivalent. Two strings are equivalent if they have the same
        characters.</para>
      </note>

      <para>You can concatenate strings using adjacent string literals:</para>

      <programlisting>var s = &apos;String &apos;&apos;concatenation&apos;
        &quot; works even over line breaks.&quot;;
assert(s == &apos;String concatenation works even over line breaks.&apos;);</programlisting>

      <para>Another way to create a multi-line string: use a triple quote with
      either single or double quotation marks.</para>

      <programlisting>var s1 = &apos;&apos;&apos;
You can create
multi-line strings like this one.
&apos;&apos;&apos;;

var s2 = &quot;&quot;&quot;This is also a
multi-line string.&quot;&quot;&quot;;</programlisting>

      <para>You can create a <quote>raw</quote> string by prefixing it with
      <literal>r</literal>.</para>

      <programlisting>var s = r&quot;In a raw string, even \n isn&apos;t special.&quot;;</programlisting>

      <para>For more information on using strings, see <xref
      linkend="ch03-strings-and-regular-expressions" />.</para>
    </sect2>

    <sect2 id="booleans">
      <title>Booleans</title>

      <para>To represent boolean values, Dart has a type named
      <literal>bool</literal>. Only two objects have type bool: the boolean
      literals, <literal>true</literal> and <literal>false</literal>.</para>

      <para>When Dart expects a boolean value, only the value
      <literal>true</literal> is treated as true. All other values are treated
      as false. Unlike in JavaScript, values such as <literal>1</literal>,
      <literal>"aString"</literal>, and <literal>someObject</literal> are all
      treated as false.</para>

      <para>For example, consider the following code, which is valid both as
      JavaScript and as Dart code:</para>

      <programlisting>var name = &apos;Bob&apos;;
if (name) {
  print(&apos;You have a name!&apos;); // Prints in JavaScript, not in Dart.
}</programlisting>

      <para>If you run this code as JavaScript, without compiling to Dart, it
      prints <quote>You have a name!</quote> because <literal>name</literal>
      is a non-null object. However, in Dart running in <emphasis>production
      mode</emphasis>, the above doesn’t print at all because
      <literal>name</literal> is converted to <literal>false</literal>
      (because <literal>name != true</literal>). In Dart running in
      <emphasis>checked mode</emphasis>, the above code throws an exception
      because the <literal>name</literal> variable is not a bool.</para>

      <para>Here’s another example of code that behaves differently in
      JavaScript and Dart:</para>

      <programlisting>if (1) {
  print(&apos;JavaScript prints this line because it thinks 1 is true.&apos;);
} else {
  print(&apos;Dart in production mode prints this line.&apos;);

  // However, in checked mode, if (1) throws an exception
  // because 1 is not boolean.
}</programlisting>

      <note>
        <para>The previous two samples work only in production mode, not
        checked mode. In checked mode, an exception is thrown if a non-boolean
        is used when a boolean value is expected.</para>
      </note>

      <para>Dart’s treatment of booleans is designed to avoid the strange
      behaviors that can arise when many values can be treated as true. What
      this means for you is that, instead of using code like
      <literal>if&nbsp;(<replaceable>nonbooleanValue</replaceable>)</literal>,
      you should instead explicitly check for values. For example:</para>

      <programlisting>// Check for an empty string.
var fullName = &apos;&apos;;
assert(fullName.isEmpty());

// Check for zero.
var hitPoints = 0;
assert(hitPoints &lt;= 0);

// Check for null.
var unicorn;
assert(unicorn == null);

// Check for NaN.
var iMeantToDoThis = 0/0;
assert(iMeantToDoThis.isNaN());</programlisting>
    </sect2>

    <sect2 id="lists">
      <title>Lists</title>

      <para>Perhaps the most common collection in nearly every programming
      language is the <emphasis>array</emphasis>, or ordered group of objects.
      In Dart, arrays are <ulink
      url="http://api.dartlang.org/dart_core/List.html">List</ulink> objects,
      so we usually just call them <emphasis>lists</emphasis>.</para>

      <para>Dart list literals look like JavaScript array literals. Here’s a
      simple Dart list:</para>

      <programlisting>var list = [1,2,3];</programlisting>

      <para>Lists use zero-based indexing, where 0 is the index of the first
      element and <literal>list.length - 1</literal> is the index of the last
      element. You can get a list’s length and refer to list elements just as
      you would in JavaScript:</para>

      <programlisting>var list = [1,2,3];
assert(list.length == 3);
assert(list[1] == 2);</programlisting>

      <para>The List type and its supertype, <ulink
      url="http://api.dartlang.org/dart_core/Collection.html">Collection</ulink>,
      have many handy methods for manipulating lists. For more information
      about lists, see <xref linkend="generics" /> and <xref
      linkend="ch03-collections" />.</para>
    </sect2>

    <sect2 id="maps">
      <title>Maps</title>

      <para>In general, a map is an object that associates keys and values.
      Dart support for maps is provided by map literals and the <ulink
      url="http://api.dartlang.org/dart_core/Map.html">Map</ulink>
      type.</para>

      <para>Here’s a simple Dart map:</para>

      <programlisting>var gifts = {                         // A map literal
// Keys       Values
  &apos;first&apos;  : &apos;partridge&apos;,
  &apos;second&apos; : &apos;turtledoves&apos;,
  &apos;fifth&apos;  : &apos;golden rings&apos;
};</programlisting>

      <para>In map literals, each <emphasis>key</emphasis> must be a string.
      If you use a Map constructor, any object can be a key.</para>

      <programlisting>var map = new Map();                  // use a map constructor.
map[1] = &apos;partridge&apos;;                 // key is 1; value is &apos;partridge&apos;.
map[2] = &apos;turtledoves&apos;;               // key is 2; value is &apos;turtledoves&apos;.
map[5] = &apos;golden rings&apos;;              // key is 5; value is &apos;golden rings&apos;.</programlisting>

      <para>A map <emphasis>value</emphasis> can be any object, including
      null.</para>

      <para>You add a new key-value pair to an existing map just as you would
      in JavaScript:</para>

      <programlisting>var gifts = { &apos;first&apos;: &apos;partridge&apos; };
gifts[&apos;fourth&apos;] = &apos;calling birds&apos;;    // Add a key-value pair</programlisting>

      <para>You retrieve a value from a map the same way you would in
      JavaScript:</para>

      <programlisting>var gifts = { &apos;first&apos;: &apos;partridge&apos; };
assert(gifts[&apos;first&apos;] == &apos;partridge&apos;);</programlisting>

      <para>If you look for a key that isn’t in a map, you get a null in
      return.</para>

      <programlisting>var gifts = { &apos;first&apos;: &apos;partridge&apos; };
assert(gifts[&apos;fifth&apos;] == null);</programlisting>

      <para>Use <literal>.length</literal> to get the number of key-value
      pairs in the map:</para>

      <programlisting>var gifts = { &apos;first&apos;: &apos;partridge&apos; };
gifts[&apos;fourth&apos;] = &apos;calling birds&apos;;
assert(gifts.length == 2);</programlisting>

      <para>For more information about maps, see <xref linkend="generics" />
      and <xref linkend="ch03-maps-aka-dictionaries-or-hashes" />.</para>
    </sect2>
  </sect1>

  <sect1 id="functions">
    <title>Functions</title>

    <para>Here’s an example of implementing a function:</para>

    <programlisting>void printNumber(num number) {
  print(&apos;The number is $number.&apos;);
}</programlisting>

    <para>Although the style guide recommends specifying the parameter and
    return types, you don’t have to:</para>

    <programlisting>printNumber(number) {          // Omitting types is OK.
  print(&apos;The number is $number.&apos;);
}</programlisting>

    <para>For functions that contain just one expression, you can use a
    shorthand syntax:</para>

    <programlisting>printNumber(number) =&gt; print(&apos;The number is $number.&apos;);</programlisting>

    <para>The <literal>=&gt; <replaceable>expr</replaceable>;</literal> syntax
    is a shorthand for <literal>{ return
    <replaceable>expr</replaceable>;}</literal>. In the printNumber() function
    above, the expression is the call to the top-level print()
    function.</para>

    <note>
      <para>Only an <emphasis>expression</emphasis>—not a
      <emphasis>statement</emphasis>—can appear between the arrow (=&gt;) and
      the semicolon (;). For example, you can’t put an if statement <xref
      linkend="if-else" xrefstyle="select: page" /> there, but you can use a
      conditional (?:) expression <xref linkend="op-other"
      xrefstyle="select: page" />.</para>
    </note>

    <para>You can use types with =&gt;, although the convention is not to do
    so.</para>

    <programlisting>printNumber(num number) =&gt; print(&apos;The number is $number.&apos;); // Including types is OK.</programlisting>

    <para>Here’s an example of calling a function:</para>

    <programlisting>printNumber(123);</programlisting>

    <para>A function can have two types of parameters: required and optional.
    The required parameters are listed first, followed by any optional
    parameters.</para>

    <sect2 id="functions-optional-parameters">
      <title>Optional parameters</title>

      <para>Optional parameters can be either positional or named, but not
      both.</para>

      <para>Both kinds of optional parameter can have default values. The
      default values must be compile-time constants such as literals. If no
      default value is provided, the value is <literal>null</literal>.</para>

      <para>If you need to know whether the caller passed in a value for an
      optional parameter, use the syntax
      <literal>?<replaceable>param</replaceable></literal>.</para>

      <programlisting>if (?device) {    // Returns true if the caller specified the parameter.
  //...The user set the value. Do something with it...
}</programlisting>

      <sect3 id="functions-optional-named-parameters">
        <title>Optional named parameters</title>

        <para>When calling a function, you can specify named parameters using
        <literal><replaceable>paramName</replaceable>:
        <replaceable>value</replaceable></literal>. For example:</para>

        <programlisting>enableFlags(bold: true, hidden: false);</programlisting>

        <para>When defining a function, use
        <literal>{<replaceable>param1</replaceable>,
        <replaceable>param2</replaceable>, …}</literal> to specify named
        parameters.</para>

        <programlisting>/// Sets the [bold] and [hidden] flags to the values you specify.
enableFlags({bool bold, bool hidden}) {
  //...
}</programlisting>

        <para>Use a colon (<literal>:</literal>) to specify default
        values.</para>

        <programlisting>/**
 * Sets the [bold] and [hidden] flags to the values you specify,
 * defaulting to false.
 */
enableFlags({bool bold: false, bool hidden: false}) {
  //...
}

enableFlags(bold: true); // bold will be true; hidden will be false.</programlisting>

        <note>
          <para>The preceding two examples use documentation comments <xref
          linkend="comments-doc" xrefstyle="select:page" />.</para>
        </note>
      </sect3>

      <sect3 id="functions-optional-positional-parameters">
        <title>Optional positional parameters</title>

        <para>Wrapping a set of function parameters in <literal>[]</literal>
        marks them as optional positional parameters.</para>

        <programlisting>String say(String from, String msg, [String device]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  return result;
}</programlisting>

        <para>Here’s an example of calling this function without the optional
        parameter:</para>

        <programlisting>assert(say('Bob', 'Howdy') == 'Bob says Howdy');</programlisting>

        <para>And here’s an example of calling this function with the third
        parameter:</para>

        <programlisting>assert(say('Bob', 'Howdy', 'smoke signal') ==
  'Bob says Howdy with a smoke signal');</programlisting>

        <para>Use <literal>=</literal> to specify default values.</para>

        <programlisting>String say(String from, String msg,
  [String device='carrier pigeon', String mood]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  if (mood != null) {
    result = '$result (in a $mood mood)';
  }
  return result;
}

assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon'); </programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Functions as first-class objects</title>

      <para>You can pass a function as a parameter to another function. For
      example:</para>

      <programlisting>printElement(element) {
  print(element);
}
  
var list = [1,2,3];
list.forEach(printElement); // Pass printElement as a parameter.</programlisting>

      <para>You can also assign a function to a variable, such as:</para>

      <programlisting>var loudify = (msg) =&gt; '!!! ${msg.toUpperCase()} !!!';
assert(loudify('hello') == '!!! HELLO !!!');</programlisting>
    </sect2>

    <sect2>
      <title>Lexical closures</title>

      <para>Functions can close over variables defined in surrounding scopes.
      In the following example, makeAdder() captures the variable
      <literal>n</literal> and makes it available to the function that
      makeAdder() returns. Wherever the returned function goes, it remembers
      <literal>n</literal>.</para>

      <programlisting>/// Returns a function that adds [n] to the function's argument.
Function makeAdder(num n) {
  return (num i) =&gt; n + i;
}

main() {
  var add2 = makeAdder(2); // Create a function that adds 2.
  var add4 = makeAdder(4); // Create a function that adds 4.

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}</programlisting>
    </sect2>

    <sect2>
      <title>Return values</title>

      <para>All functions return a value. If no return value is specified, the
      statement <literal>return null;</literal> is implicitly appended to the
      function body.</para>
    </sect2>
  </sect1>

  <sect1 id="operators">
    <title>Operators</title>

    <para>Dart defines the operators shown in <xref
    linkend="operator_table" />. You can override many of these operators, as
    described in <xref linkend="classes-operators" />.</para>

    <table class="operatorTable" id="operator_table">
      <title>Operators and their precedence</title>

      <tgroup cols="2">
        <thead>
          <row>
            <entry>Description</entry>

            <entry>Operator</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>unary postfix and argument definition test</entry>

            <entry class="operatorList"><replaceable>expr</replaceable>++
            &nbsp;&nbsp; <replaceable>expr</replaceable>-- &nbsp;&nbsp; ()
            &nbsp;&nbsp; [] &nbsp;&nbsp; . &nbsp;&nbsp;
            ?<replaceable>identifier</replaceable></entry>
          </row>

          <row>
            <entry>unary prefix</entry>

            <entry class="operatorList">-<replaceable>expr</replaceable>
            &nbsp;&nbsp; !<replaceable>expr</replaceable> &nbsp;&nbsp;
            ~<replaceable>expr</replaceable> &nbsp;&nbsp;
            ++<replaceable>expr</replaceable> &nbsp;&nbsp;
            --<replaceable>expr</replaceable> &nbsp;&nbsp;</entry>
          </row>

          <row>
            <entry>multiplicative</entry>

            <entry class="operatorList">* &nbsp;&nbsp; / &nbsp;&nbsp; %
            &nbsp;&nbsp; ~/</entry>
          </row>

          <row>
            <entry>additive</entry>

            <entry class="operatorList">+ &nbsp;&nbsp; -</entry>
          </row>

          <row>
            <entry>shift</entry>

            <entry class="operatorList">&lt;&lt; &nbsp;&nbsp; &gt;&gt;</entry>
          </row>

          <row>
            <entry>relational and type test</entry>

            <entry class="operatorList">&gt;= &nbsp;&nbsp; &gt; &nbsp;&nbsp;
            &lt;= &nbsp;&nbsp; &lt; &nbsp;&nbsp; as &nbsp;&nbsp; is
            &nbsp;&nbsp; is!</entry>
          </row>

          <row>
            <entry>equality</entry>

            <entry class="operatorList">== &nbsp;&nbsp; !=
            &nbsp;&nbsp;</entry>
          </row>

          <row>
            <entry>bitwise AND</entry>

            <entry class="operatorList">&amp;</entry>
          </row>

          <row>
            <entry>bitwise XOR</entry>

            <entry class="operatorList">^</entry>
          </row>

          <row>
            <entry>bitwise OR</entry>

            <entry class="operatorList">|</entry>
          </row>

          <row>
            <entry>logical AND</entry>

            <entry class="operatorList">&amp;&amp;</entry>
          </row>

          <row>
            <entry>logical OR</entry>

            <entry class="operatorList">||</entry>
          </row>

          <row>
            <entry>conditional</entry>

            <entry class="operatorList"><replaceable>expr1</replaceable> ?
            <replaceable>expr2</replaceable> :
            <replaceable>expr3</replaceable></entry>
          </row>

          <row>
            <entry>cascade</entry>

            <entry class="operatorList">..</entry>
          </row>

          <row>
            <entry>assignment</entry>

            <entry class="operatorList">= &nbsp;&nbsp; *= &nbsp;&nbsp; /=
            &nbsp;&nbsp; ~/= &nbsp;&nbsp; %= &nbsp;&nbsp; += &nbsp;&nbsp; -=
            &nbsp;&nbsp; &lt;&lt;= &nbsp;&nbsp; &gt;&gt;= &nbsp;&nbsp; &amp;=
            &nbsp;&nbsp; ^= &nbsp;&nbsp; |= &nbsp;&nbsp;</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>When you use operators, you create
    <glossterm>expressions</glossterm>. Here are some examples of operator
    expressions:</para>

    <programlisting>a++
a + b
a = b
a == b
a? b: c
a is T</programlisting>

    <para>In <xref linkend="operator_table" />, each operator has higher
    precedence than the operators in the rows below it. For example, the
    multiplicative operator <literal>%</literal> has higher precedence than
    (and thus executes before) the equality operator <literal>==</literal>,
    which has higher precedence than the logical AND operator
    <literal>&amp;&amp;</literal>. That precedence means that the following
    two lines of code execute the same way:</para>

    <programlisting>if ((n % i == 0) &amp;&amp; (d % i == 0)) // Parens improve readability.
if (n % i == 0 &amp;&amp; d % i == 0)     // Harder to read, but equivalent.</programlisting>

    <warning>
      <simpara>For operators that work on two operands, the leftmost operand
      determines which version of the operator is used. For example, if you
      have a Vector object and a Point object, <literal>aVector +
      aPoint</literal> uses the Vector version of +.</simpara>
    </warning>

    <sect2 id="op-arithmetic">
      <title>Arithmetic operators</title>

      <para>Dart supports the usual arithmetic operators.</para>

      <table class="operatorTable" id="arithmetic_operator_table">
        <title>Arithmetic operators</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">+</entry>

              <entry>Add</entry>
            </row>

            <row>
              <entry class="operator">–</entry>

              <entry>Subtract</entry>
            </row>

            <row>
              <entry class="operator">-<replaceable>expr</replaceable></entry>

              <entry>Unary minus, also known as negation (reverse the sign of
              the expression)</entry>
            </row>

            <row>
              <entry class="operator">*</entry>

              <entry>Multiply</entry>
            </row>

            <row>
              <entry class="operator">/</entry>

              <entry>Divide</entry>
            </row>

            <row>
              <entry class="operator">~/</entry>

              <entry>Divide, returning an integer result</entry>
            </row>

            <row>
              <entry class="operator">%</entry>

              <entry>Get the remainder of an integer division (modulo)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Example:</para>

      <programlisting>var a = 2;
var b = 3;

assert(a + b == 5);
assert(a - b == -1);
assert(a * b == 6);
assert( a / b &gt; 0.6 &amp;&amp; a / b &lt; 0.7);
assert(a ~/ b == 0);  // Quotient
assert(a % b == 2);   // Remainder</programlisting>

      <para>Dart also supports both prefix and postfix increment and decrement
      operators.</para>

      <table class="operatorTable" id="pfix_operator_table">
        <title>Increment and decrement operators</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">++<replaceable>var</replaceable></entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> + 1 (expression value is
              <replaceable>var</replaceable> + 1)</entry>
            </row>

            <row>
              <entry class="operator"><replaceable>var</replaceable>++</entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> + 1 (expression value is
              <replaceable>var</replaceable>)</entry>
            </row>

            <row>
              <entry class="operator">--<replaceable>var</replaceable></entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> – 1 (expression value is
              <replaceable>var</replaceable> – 1)</entry>
            </row>

            <row>
              <entry class="operator"><replaceable>var</replaceable>--</entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> – 1 (expression value is
              <replaceable>var</replaceable>)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Example:</para>

      <programlisting>var a, b;

a = 0;  
b = ++a;         // Increment a before b gets its value.
assert(a == b);  // 1 == 1  

a = 0;
b = a++;         // Increment a AFTER b gets its value.
assert(a != b);  // 1 != 0

a = 0;
b = --a;         // Decrement a before b gets its value.
assert(a == b);  // -1 == -1

a = 0;
b = a--;         // Decrement a AFTER b gets its value.
assert(a != b) ; // -1 != 0</programlisting>
    </sect2>

    <sect2 id="op-equality">
      <title>Equality and relational operators</title>

      <table class="operatorTable" id="equality_operator_table">
        <title>Equality and relational operators</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">==</entry>

              <entry>Equal; see discussion below</entry>
            </row>

            <row>
              <entry class="operator">!=</entry>

              <entry>Not equal</entry>
            </row>

            <row>
              <entry class="operator">&gt;</entry>

              <entry>Greater than</entry>
            </row>

            <row>
              <entry class="operator">&lt;</entry>

              <entry>Less than</entry>
            </row>

            <row>
              <entry class="operator">&gt;=</entry>

              <entry>Greater than or equal to</entry>
            </row>

            <row>
              <entry class="operator">&lt;=</entry>

              <entry>Less than or equal to</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>To test whether two objects <replaceable>x</replaceable> and
      <replaceable>y</replaceable> represent the same thing, use the
      <literal>==</literal> operator. Here’s how the <literal>==</literal>
      operator works:</para>

      <orderedlist>
        <listitem>
          <simpara>If <replaceable>x</replaceable> or
          <replaceable>y</replaceable> is null, return true if both are null,
          and false if only one is null.</simpara>
        </listitem>

        <listitem>
          <simpara>Return the result of the method invocation
          <literal><replaceable>x</replaceable>.==(<replaceable>y</replaceable>)</literal>.
          That’s right, operators such as <literal>==</literal> are methods
          that are invoked on their first operand. You’ll see more about this
          in <xref linkend="classes-operators" />.</simpara>
        </listitem>
      </orderedlist>

      <para>Here’s an example of using each of the equality and relational
      operators:</para>

      <programlisting>var a = 2;
var b = 3;
var c = a;

assert(a == 2);       // 2 and 2 are equal.
assert(a != b);       // 2 and 3 aren't equal.
assert(b &gt; a);        // 3 is more than 2.
assert(a &lt; b);        // 2 is less then 3.
assert(b &gt;= b);       // 3 is greater than or equal to 3.
assert(a &lt;= b);       // 2 is less than or equal to 3.</programlisting>
    </sect2>

    <sect2>
      <title>Type test operators</title>

      <para>The <literal>as</literal>, <literal>is</literal>, and
      <literal>is!</literal> operators are handy for checking types at
      runtime.</para>

      <table class="typeTestTable" id="type_test_operator_table">
        <title>Type test operators</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>as</entry>

              <entry>Typecast</entry>
            </row>

            <row>
              <entry class="operator">is</entry>

              <entry>True if the object has the specified type</entry>
            </row>

            <row>
              <entry class="operator">is!</entry>

              <entry>False if the object has the specified type</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The result of <literal>obj is T</literal> is true if
      <literal>obj</literal> implements the interface specified by
      <literal>T</literal>. For example, <literal>obj is Object</literal> is
      always true.</para>

      <para>Use the <literal>as</literal> operator to cast an object to a
      particular type. In general, you should use it as a shorthand for an
      <literal>is</literal> test on an object following by an expression using
      that object. For example, consider the following code:</para>

      <programlisting>if (person is Person) {               // Type check
  person.firstName = 'Bob';
}</programlisting>

      <para>You can make the code shorter using the <literal>as</literal>
      operator:</para>

      <programlisting>(person as Person).firstName = 'Bob';</programlisting>
    </sect2>

    <sect2 id="op-assign">
      <title>Assignment operators</title>

      <para>As you’ve already seen, you assign values using the
      <literal>=</literal> operator. You can also use compound assignment
      operators such as <literal>+=</literal>, which combine an operation with
      an assignment.</para>

      <table id="assignment_operator_table">
        <title>Assignment operators</title>

        <tgroup cols="4">
          <tbody>
            <row>
              <entry>=</entry>

              <entry>*=</entry>

              <entry>%=</entry>

              <entry>&amp;=</entry>
            </row>

            <row>
              <entry>+=</entry>

              <entry>/=</entry>

              <entry>&lt;&lt;=</entry>

              <entry>^=</entry>
            </row>

            <row>
              <entry>–=</entry>

              <entry>~/=</entry>

              <entry>&gt;&gt;=</entry>

              <entry>|=</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Here’s how compound assignment operators work:</para>

      <informaltable id="assignment_operator_concepts_table">
        <tgroup cols="3">
          <thead>
            <row>
              <entry></entry>

              <entry>Compound assignment</entry>

              <entry>Equivalent expression</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><emphasis role="bold">For an operator
              <replaceable>op</replaceable>:</emphasis></entry>

              <entry><literal>a <replaceable>op</replaceable>=
              b</literal></entry>

              <entry><literal>a = a <replaceable>op</replaceable>
              b</literal></entry>
            </row>

            <row>
              <entry><emphasis role="bold">Example: </emphasis></entry>

              <entry><literal>a += b</literal></entry>

              <entry><literal>a = a + b</literal></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The following example uses both assignment and compound assignment
      operators:</para>

      <programlisting>var a = 2;           // Assign using =
a *= 3;              // Assign and multiply: a = a * 3
assert(a == 6);</programlisting>
    </sect2>

    <sect2 id="op-logical">
      <title>Logical operators</title>

      <para>You can invert or combine boolean expressions using the logical
      operators.</para>

      <table class="operatorTable" id="logical_operator_table">
        <title>Logical operators</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">!<replaceable>expr</replaceable></entry>

              <entry>inverts the following expression (changes false to true,
              and vice versa)</entry>
            </row>

            <row>
              <entry class="operator">||</entry>

              <entry>logical OR</entry>
            </row>

            <row>
              <entry class="operator">&amp;&amp;</entry>

              <entry>logical AND</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Here’s an example of using the logical operators.</para>

      <programlisting>if (!done &amp;&amp; (col == 0 || col == 3)) {
  // ...Do something...
}</programlisting>
    </sect2>

    <sect2 id="op-bit">
      <title>Bitwise and shift operators</title>

      <para>You can manipulate the individual bits of numbers in Dart.
      Usually, you’d use these bitwise and shift operators with
      integers.</para>

      <table class="operatorTable" id="bit_operator_table">
        <title>Bitwise and shift operators</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">&amp;</entry>

              <entry>AND</entry>
            </row>

            <row>
              <entry class="operator">|</entry>

              <entry>OR</entry>
            </row>

            <row>
              <entry class="operator">^</entry>

              <entry>XOR</entry>
            </row>

            <row>
              <entry class="operator">~<replaceable>expr</replaceable></entry>

              <entry>Unary bitwise complement (0s become 1s; 1s become
              0s)</entry>
            </row>

            <row>
              <entry class="operator">&lt;&lt;</entry>

              <entry>Shift left</entry>
            </row>

            <row>
              <entry class="operator">&gt;&gt;</entry>

              <entry>Shift right</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Here’s an example of using bitwise and shift operators.</para>

      <programlisting>final value = 0x22;
final bitmask = 0x0f;

assert((value &amp; bitmask)  == 0x02);  // AND
assert((value &amp; ~bitmask) == 0x20);  // AND NOT
assert((value | bitmask)  == 0x2f);  // OR
assert((value ^ bitmask)  == 0x2d);  // XOR
assert((value &lt;&lt; 4)       == 0x220); // Shift left
assert((value &gt;&gt; 4)       == 0x02);  // Shift right
</programlisting>
    </sect2>

    <sect2 id="op-other">
      <title>Other operators</title>

      <para>A few operators remain, most of which you’ve already seen in other
      examples.</para>

      <table class="operatorTable" id="other_operator_table">
        <title>Other operators</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry style="text-align:center">Operator</entry>

              <entry>Name</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">()</entry>

              <entry>Function application</entry>

              <entry>Represents a function call</entry>
            </row>

            <row>
              <entry class="operator">[]</entry>

              <entry>List access</entry>

              <entry>Refers to the value at the specified index in the
              list</entry>
            </row>

            <row>
              <entry
              class="operator"><replaceable>expr1</replaceable>&nbsp;?&nbsp;<replaceable>expr2</replaceable>&nbsp;:&nbsp;<replaceable>expr3</replaceable></entry>

              <entry>Conditional</entry>

              <entry>If <replaceable>expr1</replaceable> is true, executes
              <replaceable>expr2</replaceable>; otherwise, executes
              <replaceable>expr3</replaceable></entry>
            </row>

            <row>
              <entry class="operator">.</entry>

              <entry>Member access</entry>

              <entry>Refers to a property of an expression; example:
              <literal>foo.bar</literal> selects property
              <literal>bar</literal> from expression
              <literal>foo</literal></entry>
            </row>

            <row>
              <entry class="operator">..</entry>

              <entry>Cascade</entry>

              <entry class="operator">Allows you to perform multiple
              operations on the members of a single object; described in <xref
              linkend="classes" /></entry>
            </row>

            <row>
              <entry>?<replaceable>identifier</replaceable></entry>

              <entry>Argument definition test</entry>

              <entry>Tests whether the caller specified an optional parameter;
              described in <xref
              linkend="functions-optional-parameters" /></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>
  </sect1>

  <sect1 id="control-flow">
    <title>Control flow statements</title>

    <para>You can control the flow of your Dart code using any of the
    following:</para>

    <itemizedlist>
      <listitem>
        <simpara><literal>if</literal> and <literal>else</literal></simpara>
      </listitem>

      <listitem>
        <simpara><literal>for</literal> loops</simpara>
      </listitem>

      <listitem>
        <simpara><literal>while</literal> and
        <literal>do</literal>-<literal>while</literal> loops</simpara>
      </listitem>

      <listitem>
        <simpara><literal>break</literal> and
        <literal>continue</literal></simpara>
      </listitem>

      <listitem>
        <simpara><literal>switch</literal> and
        <literal>case</literal></simpara>
      </listitem>

      <listitem>
        <simpara><literal>assert</literal></simpara>
      </listitem>
    </itemizedlist>

    <para>You can also affect the control flow using
    <literal>try-catch</literal> and <literal>throw</literal>, as explained in
    <xref linkend="exceptions" />.</para>

    <sect2 id="if-else">
      <title>If and else</title>

      <para>Dart supports <literal>if</literal> statements with optional
      <literal>else</literal> statements. Also see conditional expressions
      (?:), covered in <xref linkend="op-other" />.</para>

      <programlisting>if (isRaining()) {
  you.bringRainCoat();
} else if (isSnowing()) {
  you.wearJacket();
} else {
  car.putTopDown();
}</programlisting>

      <para>Remember, unlike JavaScript, Dart treats all values other than
      <literal>true</literal> as <literal>false</literal>. See <xref
      linkend="booleans" /> for more information.</para>
    </sect2>

    <sect2 id="for-loops">
      <title>For loops</title>

      <para>You can iterate with the standard <literal>for</literal>
      loop.</para>

      <programlisting>for (int i = 0; i &lt; candidates.length; i++) {
  candidates[i].interview();
}</programlisting>

      <para>Closures inside of Dart’s <literal>for</literal> loops capture the
      value of the index, avoiding a common pitfall found in JavaScript. For
      example, consider:</para>

      <programlisting>var callbacks = [];
for (var i = 0; i &lt; 2; i++) {
  callbacks.add(() =&gt; print(i));
}
callbacks.forEach((c) =&gt; c());</programlisting>

      <para>The output is <literal>0</literal> and then <literal>1</literal>,
      as expected. In contrast, the example would print <literal>2</literal>
      and then <literal>2</literal> in JavaScript.</para>

      <para>If the object that you are iterating over is a Collection, you can
      use the <ulink
      url="http://api.dartlang.org/dart_core/Collection.html#forEach">forEach()</ulink>
      method. Using forEach() is a good option if you don’t need to know the
      current iteration counter.</para>

      <programlisting>candidates.forEach((candidate) =&gt; candidate.interview());</programlisting>

      <para>Collections also support the <literal>for-in</literal> form of
      iteration, as described in <xref linkend="ch03-iteration" />.</para>

      <programlisting>var collection = [0, 1, 2];
for (var x in collection) {
  print(x);
}
</programlisting>
    </sect2>

    <sect2 id="while">
      <title>While and do-while</title>

      <para>A <literal>while</literal> loop evaluates the condition before the
      loop.</para>

      <programlisting>while(!isDone()) {
  doSomething();
}</programlisting>

      <para>A <literal>do</literal>-<literal>while</literal> loop evaluates
      the condition <emphasis>after</emphasis> the loop.</para>

      <programlisting>do {
  printLine();
} while (!atEndOfPage());</programlisting>
    </sect2>

    <sect2 id="break">
      <title>Break and continue</title>

      <para>Use <literal>break</literal> to stop looping.</para>

      <programlisting>while (true) {
  if (shutDownRequested()) break;
  processIncomingRequests();
}</programlisting>

      <para>Use <literal>continue</literal> to skip to the next loop
      iteration.</para>

      <programlisting>for (int i = 0; i &lt; candidates.length; i++) {
  var candidate = candidates[i];
  if (candidate.yearsExperience &lt; 5) {
    continue;
  }
  candidate.interview();
}</programlisting>

      <para>You might write that example differently if you’re using a <ulink
      url="http://api.dartlang.org/dart_core/Collection.html">Collection.</ulink></para>

      <programlisting>candidates.filter((c) =&gt; c.yearsExperience &gt;= 5)
          .forEach((c) =&gt; c.interview());</programlisting>
    </sect2>

    <sect2 id="switch">
      <title>Switch and case</title>

      <para>Switch statements in Dart compare integer, string, or compile-time
      constants using <literal>==</literal>. The compared objects must all be
      instances of the same class (and not of any of its subtypes), and the
      class must not override <literal>==</literal>.</para>

      <para>Each non-empty <literal>case</literal> clause ends with a
      <literal>break</literal> statement, as a rule. Other valid ways to end a
      non-empty <literal>case</literal> clause are a
      <literal>continue</literal>, <literal>throw</literal>, or
      <literal>return</literal> statement.</para>

      <para>Use a <literal>default</literal> clause to execute code when no
      <literal>case</literal> clause matches.</para>

      <programlisting>var command = 'OPEN';
switch (command) {
  case 'CLOSED':
    executeClosed();
    break;
  case 'PENDING':
    executePending();
    break;
  case 'APPROVED':
    executeApproved();
    break;
  case 'DENIED':
    executeDenied();
    break;
  case 'OPEN':
    executeOpen();
    break;
  default:
    executeUnknown();
}</programlisting>

      <para>The following example omits the <literal>break</literal> statement
      in the <literal>case</literal> clause, thus generating an error:</para>

      <programlisting>var command = 'OPEN';
switch (command) {
  case 'OPEN':
    executeOpen();
    // ERROR: Missing break causes an exception to be thrown!!

  case 'CLOSED':
    executeClosed();
    break;
}</programlisting>

      <para>However, Dart does support empty <literal>case</literal> clauses,
      allowing a form of fall-through.</para>

      <programlisting>var command = 'CLOSED';
switch (command) {
  case 'CLOSED':     // Empty case falls through.
  case 'NOW_CLOSED':
    // Runs for both CLOSED and NOW_CLOSED.
    executeNowClosed();
    break;
}</programlisting>

      <para>If you really want fall-through, you can use a
      <literal>continue</literal> statement and a label.</para>

      <programlisting>var command = 'CLOSED';
switch (command) {
  case 'CLOSED':
    executeClosed();
    continue nowClosed; // Continues executing at the nowClosed label.

nowClosed:
  case 'NOW_CLOSED':
    // Runs for both CLOSED and NOW_CLOSED.
    executeNowClosed();
    break;
}</programlisting>

      <para>A <literal>case</literal> clause can have local variables, which
      are visible only inside the scope of that clause.</para>
    </sect2>

    <sect2 id="assert">
      <title>Assert</title>

      <para>Use an <literal>assert</literal> statement to disrupt normal
      execution if a boolean condition is false. You can find examples of
      assert statements throughout this tour. Here are some more:</para>

      <programlisting>assert(text != null);  // Make sure the variable has a non-null value.
assert(number &lt; 100);  // Make sure the value is less than 100.
assert(urlString.startsWith('https')); // Make sure this is an HTTPS URL.
</programlisting>

      <note>
        <para>Assert statements work only in checked mode. They have no effect
        in production mode.</para>
      </note>

      <para>Inside the parentheses after <literal>assert</literal>, you can
      put any expression that resolves to a boolean value or to a function. If
      the expression’s value or function’s return value is true, the assertion
      succeeds and execution continues. Otherwise, the assertion fails and an
      exception (an <ulink
      url="http://api.dartlang.org/dart_core/AssertionError.html">AssertionError</ulink>)
      is thrown.</para>
    </sect2>
  </sect1>

  <sect1 id="exceptions">
    <title>Exceptions</title>

    <para>Your Dart code can throw and catch exceptions. Exceptions are errors
    indicating that something unexpected happened. If the exception isn’t
    caught, the isolate that raised the exception is suspended, and typically
    the isolate and its program are terminated.</para>

    <para>In contrast to Java, all of Dart’s exceptions are unchecked
    exceptions. Methods do not declare which exceptions they might throw, and
    you are not required to catch any exceptions.</para>

    <para>Dart provides <ulink
    url="http://api.dartlang.org/dart_core/Exception.html">Exception</ulink>
    and <ulink
    url="http://api.dartlang.org/docs/continuous/dart_core/Error.html">Error</ulink>
    types, as well as numerous predefined subtypes. You can, of course, define
    your own exceptions. However, Dart programs can throw any non-null
    object—not just Exception and Error objects—as an exception.</para>

    <sect2>
      <title>Throw</title>

      <para>Here’s an example of throwing, or <emphasis>raising</emphasis>, an
      exception.</para>

      <programlisting>throw new ExpectException('Value must be greater than zero');</programlisting>

      <para>You can also throw arbitrary objects.</para>

      <programlisting>throw 'Out of llamas!';</programlisting>

      <para>Because throwing an exception is an expression, you can throw
      exceptions in =&gt; statements, as well as anywhere else that allows
      expressions:</para>

      <programlisting>String get prettyVersion() =&gt; throw const NotImplementedException();
</programlisting>
    </sect2>

    <sect2>
      <title>Catch</title>

      <para>Catching, or capturing, an exception stops the exception from
      propagating. Catching an exception gives you a chance to handle
      it.</para>

      <programlisting>try {
  breedMoreLlamas();
} on OutOfLlamasException {
  buyMoreLlamas();
}</programlisting>

      <para>To handle code that can throw more than one type of exception, you
      can specify multiple catch clauses. The first catch clause that matches
      the thrown object’s type handles the exception. If the catch clause does
      not specify a type, that clause can handle any type of thrown
      object.</para>

      <programlisting>try {
  breedMoreLlamas();
} on OutOfLlamasException {           // A specific exception
  buyMoreLlamas();
} on Exception catch(e) {             // Anything else that is an exception
  print('Unknown exception: $e');
} catch(e) {                          // No specified type, handles all
  print('Something really unknown: $e');
}</programlisting>

      <para>As the preceding code shows, you can use either
      <literal>on</literal> or <literal>catch</literal> or both. Use
      <literal>on</literal> when you need to specify the exception type. Use
      <literal>catch</literal> when your exception handler needs the exception
      object.</para>
    </sect2>

    <sect2>
      <title>Finally</title>

      <para>To ensure that some code runs whether or not an exception is
      thrown, use a <literal>finally</literal> clause. If no catch clause
      matches the exception, the exception is propagated after the finally
      clause runs.</para>

      <programlisting>try {
  breedMoreLlamas();
} finally {
  cleanLlamaStalls();  // Always clean up, even if an exception is thrown.
}</programlisting>

      <para>The finally clause runs after any matching catch clauses.</para>

      <programlisting>try {
  breedMoreLlamas();
} catch(e) {
  print('Error: $e');  // Handle the exception first.
} finally {
  cleanLlamaStalls();  // Then clean up.
}</programlisting>

      <para>Learn more by reading <xref linkend="ch03-exceptions" />.</para>
    </sect2>
  </sect1>

  <sect1 id="classes">
    <title>Classes</title>

    <para>Dart is an object-oriented language with classes and single
    inheritance. Every object is an instance of a class, and all classes
    descend from <ulink
    url="http://api.dartlang.org/dart_core/Object.html">Object</ulink>.</para>

    <para>To create an object, you can use the <literal>new</literal> keyword
    with a <glossterm>constructor</glossterm> for a class. Constructor names
    can be either <emphasis><replaceable>ClassName</replaceable></emphasis> or
    <replaceable>ClassName.identifier</replaceable>.</para>

    <programlisting>var jsonData = JSON.parse('{"x":1, "y":2}');

var p1 = new Point(2,2);               // Create a Point with the Point() constructor.
var p2 = new Point.fromJson(jsonData); // Create a Point with the Point.fromJson() constructor.</programlisting>

    <para>Objects have <glossterm>members</glossterm> consisting of functions
    and data (<glossterm>methods</glossterm> and <glossterm>instance
    variables</glossterm>, respectively). When you call a method, you
    <emphasis>invoke</emphasis> it on an object: the method has access to that
    object’s functions and data.</para>

    <para>Use a dot (.) to refer to an instance variable or method.</para>

    <para><programlisting>var p = new Point(2,2);

p.y = 3;             // Set the value of the instance variable y.
assert(p.y == 3);    // Get the value of y.

num distance = p.distanceTo(new Point(4,4)); // Invoke the distanceTo() method on p.</programlisting></para>

    <para>Use the cascade operator (..) when you want to perform a series of
    operations on the members of a single object.</para>

    <programlisting>query('#button')
    ..text = 'Click to Confirm'                        // Get an object, and use its
    ..classes.add('important')                         // instance variables/methods
    ..on.click.add((e) =&gt; window.alert('Confirmed!')); // without repeating yourself.</programlisting>

    <para>Some classes provide constant constructors. To create a compile-time
    constant using a constant constructor, use <literal>const</literal>
    instead of <literal>new</literal>.</para>

    <programlisting>var p = const ImmutablePoint(2,2);</programlisting>

    <para>Constructing two identical compile-time constants results in a
    single, canonical instance.</para>

    <programlisting>var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a,b)); // They are the same instance!</programlisting>

    <para>The following sections discuss how to implement classes.</para>

    <sect2>
      <title>Instance variables</title>

      <para>Here’s how you declare instance variables:</para>

      <programlisting>class Point {
  num x;      // Declare an instance variable (x), initially null.
  num y;      // Declare y, initially null.
  num z = 0;  // Declare z, initially 0.
}</programlisting>

      <para>All uninitialized instance variables have the value
      <literal>null</literal>.</para>

      <para>All instance variables generate an implicit
      <glossterm>getter</glossterm> method. Non-final, non-const instance
      variables also generate an implicit <glossterm>setter</glossterm>
      method. For details, see <xref
      linkend="classes-getters-and-setters" />.</para>

      <programlisting>class Point {
  num x;
  num y;
}

main() {
  var point = new Point();
  point.x = 4;             // Use the setter method for x.
  assert(point.x == 4);    // Use the getter method for x.
  assert(point.y == null); // Values default to null.
}</programlisting>

      <para>If you initialize an instance variable where it is declared
      (instead of in a constructor or method), the value is set when the
      instance is created, which is before the constructor and its initializer
      list execute.</para>
    </sect2>

    <sect2>
      <title>Constructors</title>

      <para>Declare a constructor by creating a function with the same name as
      its class (plus, optionally, an additional identifier as described in
      <xref linkend="ch02-constructors-named" />). The most common form of
      constructor, the generative constructor, creates a new instance of a
      class.</para>

      <programlisting>class Point {
  num x;
  num y;

  Point(num x, num y) {
    // There's a better way to do this, stay tuned.
    this.x = x;
    this.y = y;
  }
}</programlisting>

      <para>The <literal>this</literal> keyword refers to the current
      instance.</para>

      <note>
        <para>Use <literal>this</literal> only when there is a name conflict.
        Otherwise, Dart style omits the <literal>this</literal>.</para>
      </note>

      <para>The pattern of assigning a constructor argument to an instance
      variable is so common, Dart has syntactic sugar to make it easy.</para>

      <programlisting>class Point {
  num x;
  num y;

  // Syntactic sugar for setting x and y before the constructor body runs.
  Point(this.x, this.y);
}</programlisting>

      <sect3>
        <title>Default constructors</title>

        <para>If you don’t declare a constructor, a default constructor is
        provided for you. The default constructor has no arguments and invokes
        the no-argument constructor in the superclass.</para>
      </sect3>

      <sect3>
        <title>Constructors aren’t inherited</title>

        <para>Subclasses don’t inherit constructors from their superclass. A
        subclass that declares no constructors has only the default (no
        argument, no name) constructor.</para>
      </sect3>

      <sect3 id="ch02-constructors-named">
        <title>Named constructors</title>

        <para>Use a named constructor to implement multiple constructors for a
        class or to provide extra clarity.</para>

        <programlisting>class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // Named constructor
  Point.fromJson(Map json) {
    x = json['x'];
    y = json['y'];
  }
}</programlisting>

        <para>Remember that constructors are not inherited, which means that a
        superclass’s named constructor is not inherited by a subclass. If you
        want a subclass to be created with a named constructor defined in the
        superclass, you must implement that constructor in the
        subclass.</para>
      </sect3>

      <sect3>
        <title>Invoking a non-default superclass constructor</title>

        <para>By default, a constructor in a subclass calls the superclass’s
        unnamed, no-argument constructor. If the superclass doesn’t have such
        a constructor, then you must manually call one of the constructors in
        the superclass. Specify the superclass constructor after a colon (:),
        just before the constructor body (if any).</para>

        <programlisting>class Person {
  Person.fromJson(Map data) {
    print('in Person');
  }
}

class Employee extends Person {
  // Person does not have a default constructor;
  // you must call super.fromJson(data).
  Employee.fromJson(Map data) : super.fromJson(data) {
    print('in Employee');
  }
}

main() {
  var emp = new Employee.fromJson({});

  // Prints:
  // in Person
  // in Employee
}</programlisting>
      </sect3>

      <sect3>
        <title>Initializer list</title>

        <para>Besides invoking a superclass constructor, you can also
        initialize instance variables before the constructor body runs.
        Separate initializers with commas.</para>

        <para><programlisting>class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // Use an initializer list to set instance variables before the constructor body runs.
  Point.fromJson(Map json) : x = json['x'], y = json['y'] {
    print('In Point.fromJson(): ($x, $y)');
  }
}</programlisting></para>

        <warning>
          <para>The right-hand side of an initializer does not have access to
          <literal>this</literal>.</para>
        </warning>
      </sect3>

      <sect3>
        <title>Redirecting constructors</title>

        <para>Sometimes a constructor’s only purpose is to redirect to another
        constructor in the same class. A redirecting constructor’s body is
        empty, with the constructor call appearing after a colon (:).</para>

        <programlisting>class Point {
  num x;
  num y;

  Point(this.x, this.y);                // The main constructor for this class.
  Point.alongXAxis(num x) : this(x, 0); // Delegates to the main constructor.
}</programlisting>
      </sect3>

      <sect3>
        <title>Constant constructors</title>

        <para>If your class produces objects that never change, you can make
        these objects compile-time constants. To do this, define a
        <literal>const</literal> constructor and make sure that all instance
        variables are <literal>final</literal> or
        <literal>const</literal>.</para>

        <programlisting>class ImmutablePoint {
  final num x;
  final num y;
  const ImmutablePoint(this.x, this.y);
  static final ImmutablePoint origin = const ImmutablePoint(0, 0);
}</programlisting>
      </sect3>

      <sect3 id="ch02-constructor-factory">
        <title>Factory constructors</title>

        <para>Use the <literal>factory</literal> keyword when implementing a
        constructor that doesn’t always create a new instance of its class.
        For example, a factory constructor might return an instance from a
        cache, or it might return an instance of a subtype.</para>

        <para>The following example demonstrates a factory constructor
        returning objects from a cache.</para>

        <programlisting>class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to the _ in front of its name.
  static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{};
  
  factory Logger(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name];
    } else {
      final logger = new Logger._internal(name);
      _cache[name] = logger;
      return logger;
    }
  }
  
  Logger._internal(this.name);
  
  void log(String msg) {
    if (!mute) {
      print(msg);
    }
  }
}</programlisting>

        <note>
          <para>Factory constructors have no access to
          <literal>this</literal>.</para>
        </note>

        <para>To invoke a factory constructor, you use the
        <literal>new</literal> keyword:</para>

        <programlisting>var logger = new Logger('UI');
logger.log('Button clicked');</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Methods</title>

      <para>Methods are functions that provide behavior for an object.</para>

      <sect3>
        <title>Instance methods</title>

        <para>Instance methods on objects can access instance variables and
        <literal>this</literal>. The distanceTo() method in the following
        sample is an example of an instance method.</para>

        <programlisting>class Point {
  num x;
  num y;
  Point(this.x, this.y);

  num distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}</programlisting>
      </sect3>

      <sect3 id="classes-getters-and-setters">
        <title>Getters and setters</title>

        <para>Getters and setters are special methods that provide read and
        write access to an object’s properties. Recall that each instance
        variable has an implicit getter, plus a setter if appropriate. You can
        create additional properties by implementing getters and setters,
        using the <literal>get</literal> and <literal>set</literal>
        keywords.</para>

        <programlisting>class Rectangle {
  num left;
  num top;
  num width;
  num height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Define two calculated properties: right and bottom.
  num get right             =&gt; left + width;
      set right(num value)  =&gt; left = value - width;
  num get bottom            =&gt; top + height;
      set bottom(num value) =&gt; top = value - height;
}

main() {
  var rect = new Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}</programlisting>

        <para>With getters and setters, you can start with instance variables,
        later wrapping them with methods, all without changing client
        code.</para>

        <para><note>
            <para>Operators such as increment (++) work in the expected way,
            whether or not a getter is explicitly defined. To avoid any
            unexpected side effects, the operator calls the getter exactly
            once, saving its value in a temporary variable.</para>
          </note></para>
      </sect3>

      <sect3 id="ch02-method-abstract">
        <title>Abstract methods</title>

        <para>Instance, getter, and setter methods can be abstract, defining
        an interface but leaving its implementation up to other classes. To
        make a method abstract, use a semicolon (;) instead of a method
        body.</para>

        <programlisting>abstract class Doer {
  // ...Define instance variables and methods...
 
  void doSomething(); // Define an abstract method.
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // ...Provide an implementation, so the method is not abstract in this class...
  }
}</programlisting>

        <para>Calling an abstract method results in a run-time error.</para>

        <para>Also see <xref linkend="ch02-class-abstract" />.</para>
      </sect3>

      <sect3 id="classes-operators">
        <title>Operators</title>

        <para>You can override the operators shown in <xref
        linkend="overridden_operator_table" />. For example, if you define a
        Vector class, you might define a + method to add two vectors.</para>

        <table id="overridden_operator_table">
          <title>Operators that can be overridden</title>

          <tgroup cols="4">
            <tbody>
              <row>
                <entry>&lt;</entry>

                <entry>+</entry>

                <entry>|</entry>

                <entry>[]</entry>
              </row>

              <row>
                <entry>&gt;</entry>

                <entry>/</entry>

                <entry>^</entry>

                <entry>[]=</entry>
              </row>

              <row>
                <entry>&lt;=</entry>

                <entry>~/</entry>

                <entry>&amp;</entry>

                <entry>~</entry>
              </row>

              <row>
                <entry>&gt;=</entry>

                <entry>*</entry>

                <entry>&lt;&lt;</entry>

                <entry>==</entry>
              </row>

              <row>
                <entry>–</entry>

                <entry>%</entry>

                <entry>&gt;&gt;</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Here’s an example of a class that overrides the
        <literal>+</literal> and <literal>-</literal> operators.</para>

        <programlisting>class Vector {
  final int x;
  final int y;
  const Vector(this.x, this.y);

  Vector operator +(Vector v) { // Overrides + (a + b).
    return new Vector(x + v.x, y + v.y);
  }

  Vector operator -(Vector v) { // Overrides - (a - b).
    return new Vector(x - v.x, y - v.y);
  }
}

main() {
  final v = new Vector(2,3);
  final w = new Vector(2,2);

  assert(v.x == 2 &amp;&amp; v.y == 3);         // v   == (2,3)
  assert((v+w).x == 4 &amp;&amp; (v+w).y == 5); // v+w == (4,5)
  assert((v-w).x == 0 &amp;&amp; (v-w).y == 1); // v-w == (0,1)
}</programlisting>

        <para>For an example of overriding <literal>==</literal>, see <xref
        linkend="ch03-implementing-map-keys" />.</para>
      </sect3>
    </sect2>

    <sect2 id="ch02-class-abstract">
      <title>Abstract classes</title>

      <para>Use the <literal>abstract</literal> modifier to define an
      <glossterm>abstract class</glossterm>—a class that can’t be
      instantiated. Abstract classes are useful for defining interfaces, often
      with some implementation. If you want your abstract class to appear to
      be instantiable, define a factory constructor <xref
      linkend="ch02-constructor-factory" xrefstyle="select:page" />.</para>

      <para>Abstract classes often have abstract methods <xref
      linkend="ch02-method-abstract" xrefstyle="select: page" />. Here’s an
      example of declaring an abstract class that has an abstract
      method.</para>

      <programlisting>// This class is declared abstract and thus can't be instantiated.
abstract class AbstractContainer {
  // ...Define constructors, fields, methods...

  void updateChildren(); // Abstract method.
}</programlisting>

      <para>The following class isn’t abstract, and thus can be instantiated
      even though it defines an abstract method.</para>

      <programlisting>class SpecializedContainer extends AbstractContainer {
  // ...Define more constructors, fields, methods...

  void updateChildren() {
    // ...Implement updateChildren()...
  }

  void doSomething(); // Abstract method causes a warning but doesn't prevent instantiatation.
}</programlisting>
    </sect2>

    <sect2>
      <title>Implicit interfaces</title>

      <para>Every class implicitly defines an interface containing all the
      instance members of the class and of any interfaces it implements. If
      you want to create a class A that supports class B’s API without
      inheriting B’s implementation, class A should implement the B
      interface.</para>

      <para>A class implements one or more interfaces by declaring them in an
      <literal>implements</literal> clause and then providing the APIs
      required by the interfaces. For example:</para>

      <programlisting>// A person. The implicit interface contains greet().
class Person {
  final _name;          // In the interface, but visible only in this library, thanks to _.
  Person(this._name);   // Not in the interface, since this is a constructor.
  String greet(who) =&gt; 'Hello, $who. I am $_name.'; // In the interface.
}

// An implementation of the Person interface.
class Imposter implements Person {
  final _name = "";      // We have to define this, but we don't use it.
  String greet(who) =&gt; 'Hi $who. Do you know who I am?';
}

greetBob(Person person) =&gt; person.greet('bob');

main() {
  print(greetBob(new Person('kathy')));
  print(greetBob(new Imposter()));
}</programlisting>

      <para>Here’s an example of specifying that a class implements multiple
      interfaces:</para>

      <programlisting>class Point <emphasis role="bold">implements Comparable, Location</emphasis> {
  //...
}</programlisting>
    </sect2>

    <sect2>
      <title>Extending a class</title>

      <para>Use <literal>extends</literal> to create a subclass, and
      <literal>super</literal> to refer to the superclass.</para>

      <programlisting>class Television {
  void turnOn() {
    _illuminateDisplay();
    _activateIrSensor();
  }
}

class SmartTelevision extends Television {
  void turnOn() {
    super.turnOn();
    _bootNetworkInterface();
    _initializeMemory();
    _upgradeApps();
  }
}</programlisting>

      <para>Subclasses can override instance methods, getters, and
      setters.</para>
    </sect2>

    <sect2>
      <title>Class variables and methods</title>

      <para>Use the <literal>static</literal> keyword to implement class-wide
      variables and methods.</para>

      <sect3>
        <title>Static variables</title>

        <para>Static variables (class variables) are useful for class-wide
        state and constants.</para>

        <programlisting>class Color {
  static const RED = const Color('red'); // A constant static variable.
  final String name;                     // An instance variable.
  const Color(this.name);                // A constant constructor.
}

main() {
  assert(Color.RED.name == 'red');
}</programlisting>

        <para>Static variables aren’t initialized until they’re used.</para>
      </sect3>

      <sect3>
        <title>Static methods</title>

        <para>Static methods (class methods) do not operate on an instance,
        and thus do not have access to <literal>this</literal>.</para>

        <programlisting>class Point {
  num x;
  num y;
  Point(this.x, this.y);

  static num distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
  }
}

main() {
  var a = new Point(2, 2);
  var b = new Point(4, 4);
  var distance = Point.distanceBetween(a,b);
  assert(distance &lt; 2.9 &amp;&amp; distance &gt; 2.8);
}</programlisting>

        <note>
          <para>Consider using top-level functions, instead of static methods,
          for common or widely used utilities and functionality.</para>
        </note>

        <para>You can use static methods as compile-time constants. For
        example, you can pass a static method as a parameter to a constant
        constructor.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="generics">
    <title>Generics</title>

    <para>If you look at the API documentation for the basic array type,
    <ulink url="http://api.dartlang.org/dart_core/List.html">List,</ulink>
    you’ll see that the type is actually <literal>List&lt;E&gt;</literal>. The
    &lt;...&gt; notation marks List as a <emphasis>generic</emphasis> (or
    <emphasis>parameterized</emphasis>) type—a type that has formal type
    parameters.</para>

    <note>
      <para>By convention, type variables have single-letter names, such as E,
      T, S, K, and V.</para>
    </note>

    <sect2>
      <title>Why use generics?</title>

      <para>Because types are optional in Dart, you never
      <emphasis>have</emphasis> to use generics. You might
      <emphasis>want</emphasis> to, though, for the same reason you might want
      to use other types in your code: types (generic or not) let you document
      and annotate your code, making your intent clearer.</para>

      <para>For example, if you intend for a list to contain only strings, you
      can declare it as <literal>List&lt;String&gt;</literal> (read that as
      <quote>list of string</quote>). That way you, your fellow programmers,
      and your tools (such as Dart Editor and the Dart VM in checked mode) can
      detect that assigning a non-string to the list is probably a
      mistake.</para>

      <programlisting>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
//...
names.add(42); // Fails in checked mode (succeeds in production mode).</programlisting>

      <para>Another reason for using generics is to reduce code duplication.
      Generics let you share a single interface and implementation between
      many types, while still taking advantage of checked mode and static
      analysis early warnings. For example, say you create an interface for
      caching an object:</para>

      <programlisting>abstract class ObjectCache {
  Object getByKey(String key);
  setByKey(String key, Object value);
}</programlisting>

      <para>You discover that you want a string-specific version of this
      interface, so you create another interface:</para>

      <programlisting>abstract class StringCache {
  String getByKey(String key);
  setByKey(String key, String value);
}</programlisting>

      <para>Later, you decide you want a number-specific version of this
      interface... You get the idea.</para>

      <para>Generic types can save you the trouble of creating all these
      interfaces. Instead, you can create a single interface that takes a type
      parameter:</para>

      <programlisting>abstract class Cache&lt;T&gt; {
  T getByKey(String key);
  setByKey(String key, T value);
}</programlisting>

      <para>In this code, T is the stand-in type. It’s a placeholder that you
      can think of as a type that a developer will define later.</para>
    </sect2>

    <sect2 id="generics-literals">
      <title>Using collection literals</title>

      <para>List and map literals can be parameterized. Parameterized literals
      are just like the literals you’ve already seen, except that you add
      <literal>&lt;<replaceable>type</replaceable>&gt;</literal> (for lists)
      or <literal>&lt;<replaceable>keyType</replaceable>,
      <replaceable>valueType</replaceable>&gt;</literal> (for maps) before the
      opening bracket. You might use parameterized literals when you want type
      warnings in checked mode. Here is example of using typed
      literals:</para>

      <programlisting>var names = &lt;String&gt;['Seth', 'Kathy', 'Lars'];
var pages = &lt;String, String&gt;{
    'index.html':'Homepage',
    'robots.txt':'Hints for web robots',
    'humans.txt':'We are people, not machines' };</programlisting>

      <note>
        <para>Map literals always have string <emphasis>keys</emphasis>, so
        their type is always <literal>&lt;String,
        <replaceable>SomeType</replaceable>&gt;</literal>.</para>
      </note>
    </sect2>

    <sect2 id="generics-constructors">
      <title>Using constructors</title>

      <para>To specify one or more types when using a constructor, put the
      types in angle brackets (<literal>&lt;...&gt;</literal>) just after the
      class name. For example:</para>

      <programlisting>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
var nameSet = new Set&lt;String&gt;.from(names);</programlisting>

      <para>The following code creates a map that has integer keys and values
      of type View:</para>

      <programlisting>var views = new Map&lt;int, View&gt;();
</programlisting>
    </sect2>

    <sect2 id="generics-collections">
      <title>Generic collections and the types they contain</title>

      <para>Dart generic types are <emphasis>reified</emphasis>, which means
      that they carry their type information around at runtime. For example,
      you can test the type of a collection, even in production mode:</para>

      <programlisting>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
print(names is List&lt;String&gt;); // true</programlisting>

      <para>However, the <literal>is</literal> expression checks the type of
      the <emphasis>collection</emphasis> only—not of the objects inside it.
      In production mode, a List&lt;String&gt; might have some non-string
      items in it. The solution is to either check each item’s type or wrap
      item-manipulation code in an exception handler (see <xref
      linkend="exceptions" />).</para>

      <note>
        <para>In contrast, generics in Java use <emphasis>erasure</emphasis>,
        which means that generic type parameters are removed at runtime. In
        Java, you can test whether an object is a List, but you can’t test
        whether it’s a List&lt;String&gt;.</para>
      </note>

      <para>For more information about generics, see <ulink
      url="http://www.dartlang.org/articles/optional-types/">Optional Types in
      Dart.</ulink></para>
    </sect2>
  </sect1>

  <sect1 id="libraries">
    <title>Libraries and visibility</title>

    <para>The <literal>import</literal>, <literal>part</literal>, and
    <literal>library</literal> directives can help you create a modular and
    shareable code base. Libraries not only provide APIs, but are a unit of
    privacy: identifiers that start with an underscore (_) are visible only
    inside the library.</para>

    <note>
      <para><emphasis>Every Dart app is a library</emphasis>, even if it
      doesn’t use a library directive.</para>
    </note>

    <para>Libraries can be distributed using packages. See <xref
    linkend="ch04-tools-pub" /> for information about pub, a package manager
    included in the SDK.</para>

    <sect2 id="libraries-import">
      <title>Using libraries</title>

      <para>Use <literal>import</literal> to specify how a namespace from one
      library is used in the scope of another library.</para>

      <para>For example, Dart web apps generally use the <ulink
      url="http://api.dartlang.org/html.html">dart:html</ulink> library, which
      they can import like this:</para>

      <programlisting>import 'dart:html';</programlisting>

      <para>The only required argument to <literal>import</literal> is a
      URI<footnote>
          <para>URI stands for <glossterm>uniform resource
          identifier</glossterm>. URLs (<glossterm>uniform resource
          locators</glossterm>) are a common kind of URI.</para>
        </footnote> specifying the library. For built-in libraries, the URI
      has the special <literal>dart:</literal> scheme. For other libraries,
      you can use a file system path or the <literal>package:</literal>
      scheme. The <literal>package:</literal> scheme specifies libraries
      provided by a package manager such as the pub tool. For example:</para>

      <programlisting>import 'dart:io';
import 'package:mylib/mylib.dart';
import 'package:utils/utils.dart';</programlisting>

      <sect3 id="libraries-prefix">
        <title>Specifying a library prefix</title>

        <para>If you import two libraries that have conflicting identifiers,
        then you can specify a prefix for one or both libraries. For example,
        if library1 and library2 both have an Element class, then you might
        have code like this:</para>

        <programlisting>import 'package:lib1/lib1.dart';
import 'package:lib2/lib2.dart' as lib2;
//...
var element1 = new Element();      // Uses Element from lib1.
var element2 = new lib2.Element(); // Uses Element from lib2.</programlisting>
      </sect3>

      <sect3>
        <title>Importing only part of a library</title>

        <para>If you want to use only part of a library, you can selectively
        import the library. For example:</para>

        <programlisting>import 'package:lib1/lib1.dart' show foo, bar; // Import only foo and bar from lib1.
import 'package:lib2/lib2.dart' hide foo;      // Import all names EXCEPT foo from lib2.</programlisting>
      </sect3>
    </sect2>

    <sect2 id="libraries-implementing">
      <title>Implementing libraries</title>

      <para>Use the <literal>part</literal> directive to specify the files
      that are part of a library, and <literal>library</literal> to specify
      that a file declares a library.</para>

      <sect3 id="libraries-part">
        <title>Using multiple files</title>

        <para>Whether or not you specify a <literal>library</literal>
        directive, you can use <literal>part</literal> to specify the files
        that implement the current library.</para>

        <programlisting>// No library directive; this file defines an anonymous library.
part 'ball.dart';   // Part of this library's implementation is in ball.dart.
part 'util.dart';   // Another part is in util.dart.

import 'dart:html'; // This app uses the HTML library.
//...
main() {            // Having a main() method makes this an app (and thus a library).
  //...
}</programlisting>
      </sect3>

      <sect3 id="libraries-library">
        <title>Declaring a library</title>

        <para>To explicitly declare a library, use a
        <literal>library</literal> statement. For example:</para>

        <programlisting>library ballgame;   // Declare that this is a library.

part 'ball.dart';   // Part of this library's implementation is in ball.dart.
part 'util.dart';   // Another part is in util.dart.

import 'dart:html'; // This app uses the HTML library.
//...
main() {            // We could move this code to another file in this library.
  //...
}</programlisting>
      </sect3>

      <sect3 id="libraries-source">
        <title>Associating a file with a library</title>

        <para>You can use <literal>part</literal> followed by
        <literal>of</literal> (<literal>part of</literal>) in implementation
        files to specify that the file is associated with a library. Using
        <literal>part of</literal> is optional, but it helps tools such as
        Dart Editor. Here’s an example of using <literal>part</literal> and
        <literal>part of</literal>:</para>

        <programlisting>// In ballgame.dart:
library ballgame;

import 'dart:utf';
// ...Other imports go here...

part 'ball.dart';
part 'util.dart';

//...


// In ball.dart:
part of ballgame;

// ...code goes here...


// In util.dart:
part of ballgame;

// ...code goes here...</programlisting>
      </sect3>

      <sect3>
        <title>Re-exporting libraries</title>

        <para>You can combine or repackage libraries by re-exporting part or
        all of them. For example, you might have a huge library that you
        implement as a set of smaller libraries. Or you might create a library
        that provides a subset of methods from another library.</para>

        <remark>{PENDING: As of 10/1, we weren’t able to test this example
        because export doesn’t work yet.}</remark>

        <para><programlisting><emphasis>// In french.dart:</emphasis>
library french;
hello() =&gt; print('Bonjour!');
goodbye() =&gt; print('Au Revoir!');

<emphasis>// In togo.dart:</emphasis>
library togo;
import 'french.dart';
export 'french.dart' show hello;

<emphasis>// In another .dart file:
</emphasis>import 'togo.dart';

void main() {
  hello();   //print bonjour
  goodbye(); //FAIL
}</programlisting></para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="isolates">
    <title>Isolates</title>

    <para>Modern web browsers, even on mobile platforms, run on multi-core
    CPUs. To take advantage of all those cores, developers traditionally use
    shared-memory threads running concurrently. However, shared-state
    concurrency is error prone and can lead to complicated code.</para>

    <para>Instead of threads, all Dart code runs inside of
    <emphasis>isolates</emphasis>. Each isolate has its own memory heap,
    ensuring that no isolate’s state is accessible from any other
    isolate.</para>

    <para>Learn more about isolates in <xref
    linkend="ch03-dartisolate---concurrency-with-isolates" />.</para>
  </sect1>

  <sect1 id="typedefs">
    <title>Typedefs</title>

    <para>In Dart, functions are objects, just like strings and numbers are
    objects. A <emphasis>typedef</emphasis>, or <emphasis>function-type
    alias</emphasis>, gives a function type a name that you can use when
    declaring fields and return types. A typedef retains type information when
    a function type is assigned to a variable.</para>

    <para>Consider the following code, which does not use a typedef.</para>

    <programlisting>class SortedCollection {
  Function compare;

  SortedCollection(int f(Object a, Object b)) {
    compare = f;
  }
}

int sort(Object a, Object b) =&gt; ... ; // Initial, broken implementation.

main() {
  SortedCollection collection = new SortedCollection(sort);

  // All we know is that compare is a function, but what type of function?
  assert(collection.compare is Function);
}</programlisting>

    <para>Type information is lost when assigning <literal>f</literal> to
    <literal>compare</literal>. The type of <literal>f</literal> is
    <literal>(Object, Object) → int</literal> (where → means returns), yet the
    type of <literal>compare</literal> is Function. If we change the code to
    use explicit names and retain type information, both developers and tools
    can use that information.</para>

    <programlisting><emphasis role="bold">typedef int Compare(Object a, Object b);</emphasis>

class SortedCollection {
  Compare compare;

  SortedCollection(this.compare);
}

int sort(Object a, Object b) =&gt; ... ; // Initial, broken implementation.

main() {
  SortedCollection collection = new SortedCollection(sort);
  assert(collection.compare is Function);
  assert(collection.compare is Compare);
}</programlisting>

    <note>
      <para>Currently, typedefs are restricted to function types. We expect
      this to change.</para>
    </note>

    <para>Because typedefs are simply aliases, they offer a way to check the
    type of any function. For example:</para>

    <programlisting>typedef int Compare(int a, int b);

int sort(int a, int b) =&gt; a - b;

main() {
  assert(sort is Compare);  // True!
}</programlisting>
  </sect1>

  <sect1 id="comments">
    <title>Comments</title>

    <para>Dart supports single-line comments, multi-line comments, and
    documentation comments.</para>

    <sect2>
      <title>Single-line comments</title>

      <para>A single-line comment begins with <literal>//</literal>.
      Everything between <literal>//</literal> and the end of line is ignored
      by the Dart compiler.</para>

      <programlisting>main() {
  // TODO: refactor into an AbstractLlamaGreetingFactory?
  print('Welcome to my Llama farm!');
}</programlisting>
    </sect2>

    <sect2>
      <title>Multi-line comments</title>

      <para>A multi-line comment begins with <literal>/*</literal> and ends
      with <literal>*/</literal>. Everything between <literal>/*</literal> and
      <literal>*/</literal> is ignored by the Dart compiler (unless the
      comment is a documentation comment; see the next section). Multi-line
      comments can nest.</para>

      <programlisting>main() {
  /*
   * This is a lot of work. Consider raising chickens.

  Llama larry = new Llama();
  larry.feed();
  larry.exercise();
  larry.clean();
   */
}</programlisting>
    </sect2>

    <sect2 id="comments-doc">
      <title>Documentation comments</title>

      <para>Documentation comments are multi-line or single-line comments that
      begin with <literal>/**</literal> or <literal>///</literal>. Using
      <literal>///</literal> on consecutive lines has the same effect as a
      multi-line doc comment.</para>

      <para>Inside a documentation comment, the Dart compiler ignores all text
      unless it is enclosed in brackets. Using brackets, you can refer to
      classes, methods, fields, top-level variables, functions, and
      parameters. The names in brackets are resolved in the lexical scope of
      the documented program element.</para>

      <para>Here is an example of documentation comments with references to
      other classes and arguments:</para>

      <programlisting>/**
 * The llama (Lama glama) is a domesticated South American
 * camelid, widely used as a meat and pack animal by Andean
 * cultures since pre-Hispanic times.
 */
class Llama {
  String name;

  /**
   * Feeds your llama [Food].
   * 
   * The typical llama eats one bale of hay per week.
   */
  void feed(Food food) {
    //...
  }

  /// Exercises your llama with an [activity] for
  /// [timeLimit] minutes.
  void exercise(Activity activity, int timeLimit) {
    //...
  }
}</programlisting>

      <para>In the generated documentation, <literal>[Food]</literal> becomes
      a link to the API docs for the Food class.</para>

      <para>To parse Dart code and generate HTML documentation, you can use
      Dart Editor, which in turn uses the SDK’s dartdoc package. For an
      example of generated documentation, see the <ulink
      url="http://api.dartlang.org">Dart API documentation</ulink>.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Summary</title>

    <para>This chapter summarized the commonly used features in the Dart
    language. For more information about the language, see the <ulink
    url="http://www.dartlang.org/docs/spec/">Dart Language
    Specification</ulink> and <ulink
    url="http://www.dartlang.org/articles/">articles</ulink> such as <ulink
    url="http://www.dartlang.org/articles/idiomatic-dart/"
    userlevel="">Idiomatic Dart</ulink>.</para>
  </sect1>
</chapter>
